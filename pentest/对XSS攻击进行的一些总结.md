# 简介
![在这里插入图片描述](https://img-blog.csdnimg.cn/331241786042446ba98b433e07344ea5.png)

XSS漏洞最早被发现是在1996年，由于JavaScript的出现，导致在Web应用程序中存在了一些安全问题。在1997年，高智文(Gareth Owen)也就是“XSS之父”，在他的博客中描述了一种称为“脚本注入”(script injection)的攻击技术，这就是XSS漏洞的前身。从那时起，XSS漏洞便成为了Web应用程序中的一种常见安全漏洞

xss攻击分为：
```
反射型，存储型，dom型
```
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>XSS漏洞示例</title>
</head>
<body>
    <h1>欢迎来到我的网站！</h1>
    <p>您输入的内容是：<strong><?php echo $_GET['content']; ?></strong></p>
</body>
</html>

```
上面的代码是一个简单的HTML页面，它包含一个h1标签和一个p标签。页面的p标签包含一个PHP代码片段，它将从URL参数中获取名为content的值，并将其输出到页面上。如果攻击者能够通过某种方式将恶意脚本注入到content参数中，那么它将会被执行并在用户的浏览器中运行。

例如，攻击者可以构造如下URL，将恶意脚本注入到content参数中：
```
http://example.com/xss.php?content=<script>alert('XSS攻击！');</script>
```
当用户访问上面的URL时，页面将显示一个弹窗，其中包含了攻击者注入的恶意JavaScript代码。这就是一个简单的反射型XSS攻击。
# 反射型xss攻击
反射型 XSS 攻击是指将恶意脚本注入到 URL 中，通过诱导用户点击恶意链接或提交恶意表单等方式触发漏洞，将注入的脚本反射到响应页面中，从而实现攻击的一种方式。

与存储型 XSS 攻击不同的是，反射型 XSS 攻击不需要将恶意脚本持久化到服务器上，攻击者只需要通过某种方式将恶意脚本注入到 URL 中，就可以通过用户的访问来触发漏洞。这种攻击方式的危害性相对较小，因为攻击者无法在目标网站上持久化存储恶意脚本，也无法将攻击面扩大到更多的用户。

反射型 XSS 攻击常常利用社交工程学手段，将恶意链接伪装成正常链接，诱导用户点击，从而触发漏洞。攻击者还可以利用其他的渠道，如邮件、即时通讯软件等，将恶意链接传播给更多的用户

假设一个网站上有一个搜索框，用户可以在里面输入搜索关键词。搜索结果会以HTML格式显示在页面上。现在我们可以通过在搜索框中输入恶意脚本来发起XSS反射攻击。

比如，我们可以在搜索框中输入以下内容：
```
<script>alert('XSS');</script>
```
然后，当我们点击搜索按钮时，这段恶意脚本就会被注入到页面的HTML代码中，并弹出一个警告框，显示“XSS”

# 存储型xss攻击
存储型 XSS（Cross-site scripting）攻击是一种常见的 Web 漏洞，攻击者将恶意脚本或代码存储在 Web 应用程序中，当其他用户访问该页面时，恶意代码将被执行，从而导致攻击者可以获取用户敏感信息或在受害者计算机上执行恶意操作。

与反射型 XSS 不同，存储型 XSS 攻击是在服务器端存储恶意代码，并将其保存在 Web 应用程序中，通常是在数据库或文件系统中。存储型 XSS 攻击可以通过提交包含恶意脚本的表单或评论等方式实现

假设有一个留言板的功能，用户可以在里面输入留言内容，然后将其存储到数据库中，管理员可以在后台查看留言内容。

以下是一个简单的存储型XSS攻击的例子：

前端页面：
```
<form action="submit_message.php" method="post">
    <label for="message">留言内容：</label>
    <textarea id="message" name="message"></textarea>
    <input type="submit" value="提交">
</form>
```
submit_message.php：
```
<?php
// 连接数据库
$db = new mysqli('localhost', 'username', 'password', 'database');
if ($db->connect_errno) {
    die('连接数据库失败：' . $db->connect_error);
}

// 接收留言内容
$message = $_POST['message'];

// 将留言内容存入数据库
$sql = "INSERT INTO messages (content) VALUES ('$message')";
$result = $db->query($sql);
if ($result) {
    echo '留言提交成功！';
} else {
    echo '留言提交失败！';
}

// 关闭数据库连接
$db->close();
?>
```
攻击者可以在留言板中输入以下内容：
```
<script>alert('你的网站被攻击了！')</script>
```
当管理员在后台查看留言时，将会执行这段JavaScript代码，弹出一个警告框。

如果管理员使用的是特权账户登录系统，攻击者还可以通过类似的方法窃取管理员的Cookie，获取管理员的权限，进一步危害网站的安全
# DOM型xss攻击
DOM型 XSS（Cross-Site Scripting）攻击是指攻击者利用 JavaScript、Flash 等客户端脚本语言修改页面的 DOM 结构，从而在用户浏览网页时执行恶意脚本。它不同于存储型和反射型 XSS 攻击，因为 DOM 型 XSS 攻击不会向服务器提交恶意代码，而是直接在客户端执行恶意脚本。

以下是一个简单的 DOM 型 XSS 攻击代码示例：
```
<!DOCTYPE html>
<html>
<head>
	<title>DOM XSS Example</title>
</head>
<body>
	<h1>Search Page</h1>
	<form>
		<input type="text" name="q" id="search-input">
		<button type="submit">Search</button>
	</form>
	<script>
		// 获取 URL 参数
		function getUrlParam(name) {
			const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i');
			const r = window.location.search.substr(1).match(reg);
			if (r !== null) {
				return unescape(r[2]);
			}
			return null;
		}
		// 在页面中显示搜索关键字
		const keyword = getUrlParam('q');
		document.write(`<p>Your search keyword is: ${keyword}</p>`);
	</script>
</body>
</html>
```
上面的代码展示了一个简单的搜索页面，它可以从 URL 参数中获取搜索关键字，并在页面中显示出来。攻击者可以通过在 URL 中注入恶意脚本来实现 DOM 型 XSS 攻击。例如，攻击者可以构造以下恶意 URL：
```
http://example.com/search?q=<script>alert('XSS')</script>
```
当用户打开这个 URL 时，搜索关键字就会被注入到页面中，并执行恶意脚本，弹出一个警告框。

这个例子中的 XSS 攻击漏洞在于没有对搜索关键字进行任何过滤或转义，导致用户输入的恶意脚本可以直接嵌入到页面中
# 绕过waf
1.HTML编码绕过：
可以使用一些HTML编码技术，如JavaScript编码、Unicode编码、HTML实体编码等，来绕过WAF的检测。例如，可以使用JavaScript编码来绕过WAF的脚本检测，使用Unicode编码来绕过WAF的字符检测，使用HTML实体编码来绕过WAF的特殊字符检测等。

2.混淆绕过：
可以使用一些混淆技术，如字符串拆分、大小写混合、随机空格、注释、反斜杠转义等，来混淆恶意代码，从而绕过WAF的检测。例如，可以将恶意代码拆分成多个小字符串，使用大小写混合和随机空格来隐藏代码的真实含义，使用注释和反斜杠转义来绕过WAF的注释和转义检测。

3.绕过过滤器：
可以使用一些过滤器绕过技术，如绕过JavaScript过滤器、特殊字符过滤器、协议过滤器等，来绕过WAF的检测。例如，可以使用一些特殊字符和协议来绕过WAF的过滤器，如data:、javascript:、vbscript:、about:blank等。

4.滥用DOM：
可以使用一些DOM滥用技术，如document.write()、innerHTML、setAttribute()等，来绕过WAF的检测。例如，可以使用document.write()来动态生成恶意代码，使用innerHTML来注入恶意代码，使用setAttribute()来设置恶意属性等。

5.绕过过滤器：
可以使用一些特殊的绕过过滤器技术，如JavaScript闭合、多个引号、拼接字符串、拼接数组等，来绕过WAF的检测。例如，可以使用JavaScript闭合来绕过WAF的字符串过滤器，使用多个引号来绕过WAF的字符串过滤器，使用拼接字符串和拼接数组来绕过WAF的特殊字符过滤器等。

