# 简介
![在这里插入图片描述](https://img-blog.csdnimg.cn/6bf25416a5aa4c0e81e80166ca20536c.png)
# 什么是原型链污染？
原型链污染（Prototype Pollution）是指攻击者通过篡改目标对象的原型链来实现攻击的一种方式。在 JavaScript 中，每个对象都有一个原型对象，如果对象的属性没有在本身找到，则会在原型对象中查找，如果还没有找到，则继续在原型对象的原型对象中查找，以此类推。攻击者通过污染目标对象的原型链，可以修改目标对象的属性，绕过某些安全控制，甚至执行恶意代码。常见的原型链污染攻击包括修改全局对象、污染 Node.js 内置模块、修改常用库的原型对象等

一个常见的原型链污染攻击的例子是使用一个可以接收JSON对象的应用程序。攻击者可以构造一个JSON对象，使其包含一个特殊构造的__proto__属性，该属性指向攻击者控制的恶意对象。当受害者程序解析JSON对象时，将继承恶意对象的属性和方法。攻击者可以使用这些属性和方法来执行恶意操作，例如窃取敏感信息或绕过访问控制。
具体来说，假设一个网站上有一个搜索栏，用户可以在其中输入要搜索的内容。后端应用程序使用JavaScript解析用户输入的搜索词，并使用eval()函数执行搜索操作。攻击者可以构造一个包含恶意__proto__属性的JSON对象，该属性指向一个恶意对象。当后端应用程序使用eval()函数执行搜索操作时，恶意对象的属性和方法将被继承，并可以用于执行攻击者的恶意代码。
这种攻击可以通过在JSON对象中注入恶意__proto__属性来完成。攻击者可以使用各种技术来构造恶意JSON对象，例如使用JSON.parse()函数解析恶意JSON字符串，或通过XMLHttpRequest对象发送恶意JSON数据。攻击者可以通过利用JavaScript的原型继承机制，将恶意代码注入到受害者程序中，绕过访问控制并执行攻击者的恶意操作


以下是一个简单的原型链污染攻击的代码例子：
```
// 定义一个构造函数Person
function Person(name) {
  this.name = name;
}

// 创建一个原型对象，包含一个greet()方法
Person.prototype.greet = function() {
  console.log("Hello, " + this.name);
}

// 定义一个对象，污染Person原型链
var evilObj = {
  greet: function() {
    console.log("Ha ha, I hacked your prototype!");
  }
};

// 将evilObj作为参数传递给Object.create()方法，并将其结果赋给Person原型
Person.prototype = Object.create(evilObj);

// 实例化Person对象并调用greet()方法
var person = new Person("Alice");
person.greet(); // 输出：Ha ha, I hacked your prototype!
```
在这个例子中，我们定义了一个构造函数Person和一个原型对象，其中原型对象包含一个greet()方法。然后，我们创建了一个名为evilObj的恶意对象，并将其作为参数传递给Object.create()方法，以便将其结果赋给Person原型。由于Person的原型被污染，因此实例化的Person对象现在具有恶意对象的greet()方法。因此，当我们调用person.greet()方法时，输出为“Ha ha, I hacked your prototype!”而不是原本的“Hello, Alice”。

在对网站做测试的时候，偶然发现了这个
```
?__proto__.zhero=zhero
```
![image.png](https://img-blog.csdnimg.cn/img_convert/8d2b1889c2b084725ac7bfe9a4762d46.png#averageHue=#f7f7f6&clientId=u1b425bae-d61e-4&from=paste&id=ud4e46a75&name=image.png&originHeight=447&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&size=126237&status=done&style=none&taskId=u737f0988-301d-4b4e-a940-514bc69b447&title=)
几次尝试，但没有成功，如果输入没有被递归清理：
```
__pro__proto__to__.zhero=zhero
```
构造函数（作为一个对象，它也继承了一个原型）：
```
constructor[prototype][zhero]=zhero
```
记住要针对每种情况测试访问对象的两种方式（点表示法和括号表示法）。这在绕过 WAF 后会产生影响，具体取决于 URL 及其参数的处理方式

在研究web archive上的目标时，许多 URL 都包含#字符，后面跟着有用的参数。这表明它不仅仅是一个锚点，如果应用程序使用了这个字符，那么管理 URL 及其参数的函数肯定会考虑到它
```
#__proto__[zhero]=zhero
```
经过测试，原型已经被污染了：
![image.png](https://img-blog.csdnimg.cn/img_convert/c192fd37ec2bc90ec901b7a4ff3bf686.png#averageHue=#222629&clientId=u1b425bae-d61e-4&from=paste&id=u746cbf33&name=image.png&originHeight=76&originWidth=278&originalType=url&ratio=1&rotation=0&showTitle=false&size=5699&status=done&style=none&taskId=u60846c6e-f3f3-499b-9545-e2a93f381eb&title=)
f12查看源代码，看之前通过 URL 注入的键值对在样式标签中用作的属性值
![image.png](https://img-blog.csdnimg.cn/img_convert/7547c212867c31ee0f1ea2767a8169f5.png#averageHue=#173c5b&clientId=u1b425bae-d61e-4&from=paste&id=u1aea385e&name=image.png&originHeight=43&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&size=30347&status=done&style=none&taskId=ub3309361-b46a-4121-814a-136e4b17cef&title=)
js代码里也没有过滤
![image.png](https://img-blog.csdnimg.cn/img_convert/0cd137a85f998bfd9b99b1f10eab8760.png#averageHue=#242429&clientId=u1b425bae-d61e-4&from=paste&id=u136e0148&name=image.png&originHeight=154&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&size=23000&status=done&style=none&taskId=u295de9a1-fa76-493d-a454-735097974d8&title=)
直接打
```
#__proto__[onload]=alert(%22XSS by zhero_%22)
```
![image.png](https://img-blog.csdnimg.cn/img_convert/a59a89ae92bf0ccfb797e46ab4fd7395.png#averageHue=#9fa09f&clientId=u1b425bae-d61e-4&from=paste&id=u238cfd2d&name=image.png&originHeight=126&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&size=24822&status=done&style=none&taskId=u15e6f699-6591-4117-8ef7-275d92c436f&title=)

